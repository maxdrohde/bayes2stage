\nonstopmode{}
\documentclass[a4paper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\makeatletter\@ifl@t@r\fmtversion{2018/04/01}{}{\usepackage[utf8]{inputenc}}\makeatother
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge Package `bayes2stage'}}
\par\bigskip{\large \today}
\end{center}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdftitle = {bayes2stage: Bayesian Analysis of Two-Stage Designs}}}{}
\ifthenelse{\boolean{Rd@use@hyper}}{\hypersetup{pdfauthor = {Maximilian Rohde}}}{}
\begin{description}
\raggedright{}
\item[Title]\AsIs{Bayesian Analysis of Two-Stage Designs}
\item[Version]\AsIs{0.0.0.9000}
\item[Author]\AsIs{Maximilian Rohde [aut, cre] (<}\url{https://orcid.org/0000-0002-3731-3372}\AsIs{>)}
\item[Maintainer]\AsIs{Maximilian Rohde }\email{maxdrohde@gmail.com}\AsIs{}
\item[Description]\AsIs{Provides functions for analyzing Bayesian Two-Stage Designs
using NIMBLE for model fitting, and for generating simulated data from
two-stage designs.}
\item[License]\AsIs{MIT + file LICENSE}
\item[URL]\AsIs{}\url{https://github.com/maxdrohde/bayes2stage}\AsIs{}
\item[BugReports]\AsIs{}\url{https://github.com/maxdrohde/bayes2stage/issues}\AsIs{}
\item[Depends]\AsIs{MASS, mvtnorm, nimble, nimbleEcology, nimbleMacros, numDeriv,
R (>= 4.1.0)}
\item[Imports]\AsIs{data.table, dplyr, extraDistr, ggplot2, glue, instantiate,
lme4, MCMCvis, patchwork, purrr, rlang, stats, tibble}
\item[Suggests]\AsIs{testthat (>= 3.0.0)}
\item[Config/testthat/edition]\AsIs{3}
\item[Encoding]\AsIs{UTF-8}
\item[Roxygen]\AsIs{list(markdown = TRUE)}
\item[RoxygenNote]\AsIs{7.3.3}
\end{description}
\Rdcontents{Contents}
\HeaderA{bayes2stage-package}{bayes2stage: Bayesian Analysis of Two-Stage Designs}{bayes2stage.Rdash.package}
\aliasA{bayes2stage}{bayes2stage-package}{bayes2stage}
\keyword{internal}{bayes2stage-package}
%
\begin{Description}
Provides functions for analyzing Bayesian Two-Stage Designs using NIMBLE for model fitting, and for generating simulated data from two-stage designs.
\end{Description}
%
\begin{Author}
\strong{Maintainer}: Maximilian Rohde \email{maxdrohde@gmail.com} (\Rhref{https://orcid.org/0000-0002-3731-3372}{ORCID})

\end{Author}
%
\begin{SeeAlso}
Useful links:
\begin{itemize}

\item{} \url{https://github.com/maxdrohde/bayes2stage}
\item{} Report bugs at \url{https://github.com/maxdrohde/bayes2stage/issues}

\end{itemize}


\end{SeeAlso}
\HeaderA{ACi1q}{Ascertainment correction piece for univariate sampling}{ACi1q}
%
\begin{Description}
Calculate the (not yet log transformed) ascertainment correction under a univariate Q\_i
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ACi1q(cutpoints, SampProb, mu_q, sigma_q)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{cutpoints}] cutpoints defining the sampling regions. (a vector of length 2)

\item[\code{SampProb}] Sampling probabilities from within each region (vector of length 3).

\item[\code{mu\_q}] a scalar for the mean value of the Q\_i distribution

\item[\code{sigma\_q}] a scalar for the standard deviation of the Q\_i distribution
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Not yet log transformed ascertainment correction
\end{Value}
\HeaderA{ACi2q}{Ascertainment correction piece for bivariate sampling}{ACi2q}
%
\begin{Description}
Calculate the (not yet log transformed) ascertainment correction under a bivariate Q\_i
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ACi2q(cutpoints, SampProb, mu_q, sigma_q)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{cutpoints}] cutpoints defining the sampling regions. (a vector of length 4: c(xlow, xhigh, ylow, yhigh))

\item[\code{SampProb}] Sampling probabilities from within each of two sampling regions; central region and outlying region (vector of length 2).

\item[\code{mu\_q}] a 2-vector for the mean value of the bivariate Q\_i distribution.

\item[\code{sigma\_q}] a 2 by 2 covariance matrix for the bivariate Q\_i distribution.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Not yet log transformed ascertainment correction
\end{Value}
\HeaderA{acml.lmem2}{Fitting function: ACML or WL for a linear mixed effects model (random intercept and slope)}{acml.lmem2}
%
\begin{Description}
Fitting function: ACML or WL for a linear mixed effects model (random intercept and slope)
\end{Description}
%
\begin{Usage}
\begin{verbatim}
acml.lmem2(
  formula.fixed,
  formula.random,
  data,
  id,
  w.function = "mean",
  InitVals,
  cutpoints,
  SampProb,
  Weights,
  ProfileCol = NA
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{formula.fixed}] formula for the fixed effects (of the form y\textasciitilde{}x)

\item[\code{formula.random}] formula for the random effects (of the form \textasciitilde{}z).  Right now this model only fits random intercept and slope models.

\item[\code{data}] data frame that should contain everything in formula.fixed, formula.random, id, and Weights.  It does not include: w.function, cutpoints, SampProb

\item[\code{id}] sum(n\_i) vector of subject ids (a variable contained in data)

\item[\code{w.function}] sum(n\_i) vector with possible values that include "mean" (mean of response series), "intercept" (intercept of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi* zi) * t.zi)\AsIs{\texttt{[1,]}}), "intercept1"  (intercept of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi * zi) * t.zi)\AsIs{\texttt{[1,]}}). "intercept2" (second intercept of the regression of the Yi \textasciitilde{}

\item[\code{InitVals}] starting values for c(beta, log(sigma0), log(sigma1), log((1+rho)/(1-rho)), log(sigmae))

\item[\code{cutpoints}] A matrix with the first dimension equal to sum(n\_i).  These cutpoints define the sampling regions for individual subjects.  If using a low, medium, high, sampling scheme, this is a sum(n\_i) by 2 matrix that must be a distinct object not contained in the dat dataframe.  Each row is a vector of length 2 c(k1,k2) to define the sampling regions, i.e., low, middle, high.  If using a square doughnut design this should be sum(n\_i) by 4 matrix (var1lower, var1upper, var2lower, var2upper). Each subject should have n\_i rows of the same values.

\item[\code{SampProb}] A matrix with the first dimension equal to sum(n\_i).   Sampling probabilities from within each region. For low medium high sampling, each row is a vector of length 3 with sampling probabilities for each region. For bivariate stratum sampling each row is a vector of length 2 with sampling probabilities for the inner and outer strata. Each subject should have n\_i rows of the same values.  Not in data.

\item[\code{Weights}] Subject specific sampling weights.  A vector of length sum(n\_i).  This should be a variable in the data dataframe. It should only be used if doing IPWL.  Note if doing IPWL, only use robcov (robust variances) and not covar.  If not doing IPWL, this must be a vectors of 1s.

\item[\code{ProfileCol}] the column number(s) for which we want fixed at the value of param.  Maximizing the log likelihood for all other parameters
while fixing these columns at the values of \code{InitVals[ProfileCol]}
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Ascertainment corrected Maximum likelihood: Ests, covar, LogL, code, robcov
\end{Value}
\HeaderA{bds\_design}{Set x to missing based on an BDS design}{bds.Rul.design}
%
\begin{Description}
Set x to missing based on an BDS design
\end{Description}
%
\begin{Usage}
\begin{verbatim}
bds_design(
  data,
  fixed_effects_formula,
  sampling_type,
  cutoff_high,
  cutoff_low,
  sampling_N,
  prop_high,
  prop_middle,
  prop_low
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] Dataset to use

\item[\code{fixed\_effects\_formula}] Formula for the fixed-effects when fitting the model to estimate BLUPs

\item[\code{sampling\_type}] Which type of sampling? "intercept" or "slope"

\item[\code{cutoff\_high}] Which quantile to use as the cutoff for the High category

\item[\code{cutoff\_low}] Which quantile to use as the cutoff for the Low category

\item[\code{sampling\_N}] How many subjects should be sampled?

\item[\code{prop\_high}] What proportion to sample from the High category?

\item[\code{prop\_middle}] What proportion to sample from the Middle category?

\item[\code{prop\_low}] What proportion to sample from the Low category?
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A dataset where the x values are selected based on an BDS design
\end{Value}
\HeaderA{check\_cols}{Check for required columns in a data frame}{check.Rul.cols}
%
\begin{Description}
Validates that a data frame contains all required columns.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
check_cols(data, required_cols)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] A data frame to check

\item[\code{required\_cols}] A character vector of required column names
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Invisibly returns TRUE if all columns are present; otherwise throws an error
\end{Value}
\HeaderA{CreateSubjectData}{Create a list of subject-specific data}{CreateSubjectData}
%
\begin{Description}
Create a list of subject-specific data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
CreateSubjectData(id, y, x, z, Weights, SampProb, cutpoints, w.function)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{id}] sum(n\_i) vector of subject ids

\item[\code{y}] response vector

\item[\code{x}] sum(n\_i) by p design matrix for fixed effects

\item[\code{z}] sum(n\_i) by 2 design matric for random effects (intercept and slope)

\item[\code{Weights}] Subject specific sampling weights.  A vector of length sum(n\_i).  Not used unless using weighted Likelihood

\item[\code{SampProb}] A matrix with the first dimension equal to sum(n\_i).   Sampling probabilities from within each region (bivariate Q\_i: each row is a vector of length 2 c(central region, outlying region); univariate Q\_i: each row is a vector of length 3 with sampling probabilities for each region). Each subject should have n\_i rows of the same values.

\item[\code{cutpoints}] A matrix with the first dimension equal to sum(n\_i).  These cutpoints define the sampling regions (bivariate Q\_i: each row is a vector of length 4 c(xlow, xhigh, ylow, yhigh); univariate Q\_i: each row is a vector of length 2 c(k1,k2) to define the sampling regions, i.e., low, middle, high).  Each subject should have n\_i rows of the same values.

\item[\code{w.function}] sum(n\_i) vector with possible values that include "mean" "intercept" "slope" and "bivar."  There should be one unique value per subject
\end{ldescription}
\end{Arguments}
\HeaderA{fit\_acml\_ods}{Fit ACML model for outcome-dependent sampling}{fit.Rul.acml.Rul.ods}
%
\begin{Description}
Fits an ascertainment-corrected maximum likelihood model for ODS designs.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fit_acml_ods(ods_df, cutoff_low, cutoff_high)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{ods\_df}] Data frame from ODS sampling

\item[\code{cutoff\_low}] Lower cutoff value for sampling regions

\item[\code{cutoff\_high}] Upper cutoff value for sampling regions
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame with parameter estimates and confidence intervals
\end{Value}
\HeaderA{fit\_model}{Fit a Bayesian two-stage model using NIMBLE}{fit.Rul.model}
%
\begin{Description}
Fits a mixed effects model with imputation using NIMBLE for MCMC sampling.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fit_model(
  data,
  main_model_covariates,
  imputation_model_covariates,
  imputation_model_distribution,
  correlated_random_effects = TRUE,
  nchains = 4,
  niter = 10000,
  nburnin = 2000,
  x_size = NULL,
  print_summary = FALSE,
  print_code = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] A data frame containing the outcome and covariates. Must include
columns: y (outcome), t (time), x (exposure), and id (subject identifier).

\item[\code{main\_model\_covariates}] Character vector of covariate names for the main model

\item[\code{imputation\_model\_covariates}] Character vector of covariate names for the imputation model

\item[\code{imputation\_model\_distribution}] Distribution for the imputation model.
One of: "normal", "binomial", "beta\_binomial", "poisson", "negative\_binomial"

\item[\code{correlated\_random\_effects}] Logical; if TRUE, random intercepts and slopes
are correlated (default: TRUE)

\item[\code{nchains}] Number of MCMC chains (default: 4)

\item[\code{niter}] Number of MCMC iterations per chain (default: 10000)

\item[\code{nburnin}] Number of burn-in iterations to discard (default: 2000)

\item[\code{x\_size}] Integer vector of trial sizes; required for binomial or beta\_binomial
distributions (default: NULL)

\item[\code{print\_summary}] Logical; if TRUE, prints MCMC summary (default: FALSE)

\item[\code{print\_code}] Logical; if TRUE, prints the NIMBLE model code (default: FALSE)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list containing MCMC samples and optionally WAIC
\end{Value}
\HeaderA{fit\_stan\_model}{Fit a Bayesian two-stage model using Stan}{fit.Rul.stan.Rul.model}
%
\begin{Description}
Fits a mixed effects model with imputation using Stan via the instantiate package.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
fit_stan_model(
  data,
  main_model_covariates,
  imputation_model_covariates,
  imputation_distribution = c("normal", "bernoulli", "beta_binomial",
    "negative_binomial"),
  nchains = 4,
  iter_warmup = 1000,
  iter_sampling = 1000,
  adapt_delta = 0.8,
  seed = 777L,
  parallel_chains = 1L
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] A data frame containing the outcome and covariates

\item[\code{main\_model\_covariates}] Character vector of covariate names for the main model

\item[\code{imputation\_model\_covariates}] Character vector of covariate names for the imputation model

\item[\code{imputation\_distribution}] Distribution for the imputation model:
"normal" for continuous x, "bernoulli" for binary x, "beta\_binomial"
for bounded count data, or "negative\_binomial" for unbounded count data
(default: "normal")

\item[\code{nchains}] Number of MCMC chains (default: 4)

\item[\code{iter\_warmup}] Number of warmup iterations per chain (default: 1000)

\item[\code{iter\_sampling}] Number of sampling iterations per chain (default: 1000)

\item[\code{adapt\_delta}] Target acceptance rate for HMC (default: 0.8)

\item[\code{seed}] Random seed for reproducibility (default: 777L)

\item[\code{parallel\_chains}] Number of chains to run in parallel (default: 1L)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A CmdStanMCMC fit object
\end{Value}
\HeaderA{format\_data\_mcmc}{Format the simulated data for Stan / NIMBLE}{format.Rul.data.Rul.mcmc}
%
\begin{Description}
Format the simulated data for Stan / NIMBLE
\end{Description}
%
\begin{Usage}
\begin{verbatim}
format_data_mcmc(
  data,
  main_model_covariates = NULL,
  imputation_model_covariates = NULL,
  imputation_distribution = c("normal", "bernoulli", "beta_binomial",
    "negative_binomial")
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] Dataset to use

\item[\code{main\_model\_covariates}] Character vector of column names for covariates in the main model

\item[\code{imputation\_model\_covariates}] Character vector of column names for covariates in the imputation model

\item[\code{imputation\_distribution}] Distribution for the imputation model:
"normal" for continuous x, "bernoulli" for binary x, "beta\_binomial"
for bounded count data, or "negative\_binomial" for unbounded count data
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list suitable for input to MCMC software
\end{Value}
\HeaderA{generate\_data}{Generate correlated random intercept / slope longitudinal data}{generate.Rul.data}
%
\begin{Description}
Generates simulated longitudinal data with correlated random intercepts
and slopes for testing two-stage design methods.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
generate_data(
  N = 2000,
  M = 5,
  alpha_main = 1,
  beta_x = 1,
  beta_z = 1,
  beta_t = 2,
  beta_t_x_interaction = 0.3,
  beta_t_z_interaction = 0,
  error_sd = 4,
  x_dist = c("normal", "poisson", "binomial", "negative_binomial", "beta_binomial"),
  x_size = NULL,
  x_disp_param = NULL,
  rand_intercept_sd = 3,
  rand_slope_sd = 1,
  rand_eff_corr = 0,
  gamma0 = 1,
  gamma1 = 1,
  gamma2 = 0,
  gamma_sd = 2
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{N}] Number of subjects (default: 2000)

\item[\code{M}] Number of time points per subject (default: 5)

\item[\code{alpha\_main}] Intercept for the main model (default: 1)

\item[\code{beta\_x}] Coefficient for x in the main model (default: 1)

\item[\code{beta\_z}] Coefficient for z in the main model (default: 1)

\item[\code{beta\_t}] Coefficient for time in the main model (default: 2)

\item[\code{beta\_t\_x\_interaction}] Coefficient for time-x interaction (default: 0.3)

\item[\code{beta\_t\_z\_interaction}] Coefficient for time-z interaction (default: 0)

\item[\code{error\_sd}] Standard deviation of residual error (default: 4)

\item[\code{x\_dist}] Distribution for x: "normal", "poisson", "binomial",
"negative\_binomial", or "beta\_binomial" (default: "normal")

\item[\code{x\_size}] Size parameter for binomial/beta\_binomial distributions

\item[\code{x\_disp\_param}] Dispersion parameter for negative\_binomial/beta\_binomial

\item[\code{rand\_intercept\_sd}] Standard deviation of random intercepts (default: 3)

\item[\code{rand\_slope\_sd}] Standard deviation of random slopes (default: 1)

\item[\code{rand\_eff\_corr}] Correlation between random intercepts and slopes (default: 0)

\item[\code{gamma0}] Intercept for the imputation model (default: 1)

\item[\code{gamma1}] Linear coefficient for z in the imputation model (default: 1)

\item[\code{gamma2}] Quadratic coefficient for z in the imputation model (default: 0)

\item[\code{gamma\_sd}] Standard deviation for the imputation model (normal distribution only) (default: 2)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame with simulated longitudinal data
\end{Value}
\HeaderA{generate\_data\_schild\_2019\_supp}{Generate correlated random intercept / slope longitudinal data to test two-stage design methods. In the form of Schildcrout (2019) supplement}{generate.Rul.data.Rul.schild.Rul.2019.Rul.supp}
%
\begin{Description}
Generate correlated random intercept / slope longitudinal data
to test two-stage design methods. In the form of Schildcrout (2019)
supplement
\end{Description}
%
\begin{Usage}
\begin{verbatim}
generate_data_schild_2019_supp(
  N,
  Ms,
  alpha_main,
  beta_x,
  beta_z,
  beta_t,
  beta_t_x_interaction,
  beta_t_z_interaction,
  error_sd,
  x_prevalence,
  rand_intercept_sd,
  rand_slope_sd,
  rand_eff_corr,
  gamma0,
  gamma1,
  gamma2,
  gamma_sd
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{N}] Integer. Total number of subjects in the cohort. Default is 2000.

\item[\code{Ms}] Integer vector. Possible numbers of observations per subject,
sampled uniformly. Default is c(4, 5, 6).

\item[\code{alpha\_main}] Numeric. Fixed intercept (β₀). Default is 75.

\item[\code{beta\_x}] Numeric. Main effect of binary exposure X (β\_s). Default is -0.5.

\item[\code{beta\_z}] Numeric. Effect of continuous confounder Z (β\_c). Default is -2.

\item[\code{beta\_t}] Numeric. Fixed time effect (β\_t). Default is -1.

\item[\code{beta\_t\_x\_interaction}] Numeric. Interaction between time and exposure
(β\_st). Default is -0.5.

\item[\code{beta\_t\_z\_interaction}] Numeric. Interaction between time and confounder.
Default is 0.

\item[\code{error\_sd}] Numeric. Standard deviation of measurement error (σ\_e).
Default is sqrt(12.25) = 3.5.

\item[\code{x\_prevalence}] Numeric. Prevalence of binary exposure X. Must be between
0 and 1. Default is 0.25.

\item[\code{rand\_intercept\_sd}] Numeric. Standard deviation of random intercept (σ₀).
Default is sqrt(81) = 9.

\item[\code{rand\_slope\_sd}] Numeric. Standard deviation of random slope (σ₁).
Default is sqrt(1.56) = 1.25.

\item[\code{rand\_eff\_corr}] Numeric. Correlation between random intercept and slope
(ρ). Must be between -1 and 1. Default is 0.

\item[\code{gamma0}] Numeric. Intercept for confounder Z generation. Default is 0.25.

\item[\code{gamma1}] Numeric. Linear coefficient for X in Z generation. Default is 0.5.

\item[\code{gamma2}] Numeric. Quadratic coefficient for X in Z generation. Default is 0.

\item[\code{gamma\_sd}] Numeric. Standard deviation of Z residual error. Default is 1.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
dataset
\end{Value}
\HeaderA{li.lme}{Calculate a subject-specific contribution to a log-likelihood for longitudinal normal data}{li.lme}
%
\begin{Description}
Calculate a subject-specific contribution to a log-likelihood for longitudinal normal data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
li.lme(yi, xi, beta, vi)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{yi}] n\_i-response vector

\item[\code{xi}] n\_i by p design matrix for fixed effects

\item[\code{beta}] mean model parameter vector

\item[\code{vi}] the variance covariance matrix (ZDZ+Sige2*I)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
subject specific contribution to the log-likelihood
\end{Value}
\HeaderA{li.lme.score2}{Subject specific contribution to the lme model score (also returns marginal Vi=Cov(Y|X))}{li.lme.score2}
%
\begin{Description}
Subject specific contribution to the lme model score (also returns marginal Vi=Cov(Y|X))
\end{Description}
%
\begin{Usage}
\begin{verbatim}
li.lme.score2(subjectData, beta, sigma.vc, rho.vc, sigma.e)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{subjectData}] a list that contains yi, xi, zi, Weights.i.  Note that Weights.i is used for inverse probability weighting only.

\item[\code{beta}] mean model parameter p-vector

\item[\code{sigma.vc}] vector of variance components on standard deviation scale

\item[\code{rho.vc}] vector of correlations among the random effects.  The length should be q choose 2

\item[\code{sigma.e}] std dev of the measurement error distribution
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Subject specific contribution to the log-likelihood score (also returns marginal Vi=Cov(Y|X))
\end{Value}
\HeaderA{logACi1q}{Log of the Ascertainment correction for univariate sampling}{logACi1q}
%
\begin{Description}
Calculate the log transformed ascertainment correction under a univariate Q\_i.  Also return vi
\end{Description}
%
\begin{Usage}
\begin{verbatim}
logACi1q(yi, xi, zi, wi, beta, sigma.vc, rho.vc, sigma.e, cutpoints, SampProb)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{yi}] n\_i-response vector

\item[\code{xi}] n\_i by p design matrix for fixed effects

\item[\code{zi}] n\_i by q design matric for random effects (intercept and slope)

\item[\code{wi}] the pre-multiplier of yi to generate the sampling variable q\_i

\item[\code{beta}] mean model parameter vector

\item[\code{sigma.vc}] vector of variance components on standard deviation scale

\item[\code{rho.vc}] vector of correlations among the random effects.  The length should be q choose 2

\item[\code{sigma.e}] std dev of the measurement error distribution

\item[\code{cutpoints}] cutpoints defining the sampling regions. (a vector of length 2)

\item[\code{SampProb}] Sampling probabilities from within each region (vector of length 3).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
log transformed ascertainment correction
\end{Value}
\HeaderA{logACi1q.score2}{Gradient of the log of the ascertainment correction piece for sampling based on univariate Q\_i}{logACi1q.score2}
%
\begin{Description}
Calculate the gradient of the log transformed ascertainment correction for sampling based on univariate Q\_i
\end{Description}
%
\begin{Usage}
\begin{verbatim}
logACi1q.score2(subjectData, beta, sigma.vc, rho.vc, sigma.e)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{subjectData}] a list containing: yi, xi, zi, Weights.i, w.function.i, SampProb.i, cutpoints.i

\item[\code{beta}] mean model parameter p-vector

\item[\code{sigma.vc}] vector of variance components on standard deviation scale

\item[\code{rho.vc}] vector of correlations among the random effects.  The length should be q choose 2

\item[\code{sigma.e}] std dev of the measurement error distribution
\end{ldescription}
\end{Arguments}
%
\begin{Value}
gradient of the log transformed ascertainment correction under univariate \$Q\_i\$
\end{Value}
\HeaderA{logACi2q}{Log of the Ascertainment correction piece for bivariate sampling}{logACi2q}
%
\begin{Description}
Calculate the log transformed ascertainment correction under a bivariate Q\_i.  Also return vi
\end{Description}
%
\begin{Usage}
\begin{verbatim}
logACi2q(yi, xi, zi, wi, beta, sigma.vc, rho.vc, sigma.e, cutpoints, SampProb)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{yi}] n\_i-response vector

\item[\code{xi}] n\_i by p design matrix for fixed effects

\item[\code{zi}] n\_i by q design matric for random effects (intercept and slope)

\item[\code{wi}] the pre-multiplier of yi to generate the sampling variable q\_i

\item[\code{beta}] mean model parameter p-vector

\item[\code{sigma.vc}] vector of variance components on standard deviation scale

\item[\code{rho.vc}] vector of correlations among the random effects.  The length should be q choose 2

\item[\code{sigma.e}] std dev of the measurement error distribution

\item[\code{cutpoints}] cutpoints defining the sampling regions. (a vector of length 4 c(xlow, xhigh, ylow, yhigh))

\item[\code{SampProb}] Sampling probabilities from within each region (vector of length 2 c(central region, outlying region)).
\end{ldescription}
\end{Arguments}
%
\begin{Value}
log transformed ascertainment correction
\end{Value}
\HeaderA{logACi2q.score2}{Gradient of the log of the ascertainment correction piece for sampling based on bivariate Q\_i.}{logACi2q.score2}
%
\begin{Description}
Calculate the gradient of the log transformed ascertainment correction under designs that sample based on a bivariate Q\_i (numerically).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
logACi2q.score2(subjectData, beta, sigma.vc, rho.vc, sigma.e)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{subjectData}] a list containing: yi, xi, zi, Weights.i, w.function, SampProb, cutpoints

\item[\code{beta}] mean model parameter p-vector

\item[\code{sigma.vc}] vector of variance components on standard deviation scale

\item[\code{rho.vc}] vector of correlations among the random effects.  The length should be q choose 2

\item[\code{sigma.e}] std dev of the measurement error distribution
\end{ldescription}
\end{Arguments}
%
\begin{Value}
gradient of the log transformed ascertainment correction under the bivariate sampling design
\end{Value}
\HeaderA{LogLikeC.Score2}{Calculate the gradient of the conditional likelihood for the univariate and bivariate sampling cases across all subjects (CheeseCalc=FALSE) or the cheese part of the sandwich estimator if CheeseCalc=TRUE.}{LogLikeC.Score2}
%
\begin{Description}
Calculate the gradient of the conditional likelihood for the univariate and bivariate sampling cases across all subjects (CheeseCalc=FALSE) or the cheese part of the sandwich estimator if CheeseCalc=TRUE.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
LogLikeC.Score2(
  y,
  x,
  z,
  w.function,
  id,
  beta,
  sigma.vc,
  rho.vc,
  sigma.e,
  cutpoints,
  SampProb,
  Weights,
  CheeseCalc = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{y}] response vector

\item[\code{x}] sum(n\_i) by p design matrix for fixed effects

\item[\code{z}] sum(n\_i) by 2 design matric for random effects (intercept and slope)

\item[\code{w.function}] sum(n\_i) vector with possible values that include "mean" (mean of response series), "intercept" (intercept of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[1,]}}), "intercept1"  (intercept of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[1,]}}). "intercept2" (second intercept of the regression of the Yi \textasciitilde{} zi where zi is the design matrix for the bivariate random effects (b10,b11,b20,b21) solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[3,]}}), "slope" (slope of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[2,]}}), "slope1" (slope of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[2,]}}), "slope2" (second slope of the regression of the Yi \textasciitilde{} zi where zi is the design matrix for the bivariate random effects (b10,b11,b20,b21) solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[4,]}}) "bivar" (intercept and slope of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[c(1,2),]}}) "mvints" (first and second intercepts of the bivariate regression of the Yi \textasciitilde{} zi where zi is the design matrix for the bivariate random effects (b10,b11,b20,b21) solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[c(1,3),]}}) "mvslps" (first and second slopes of the bivariate regression of the Yi \textasciitilde{} zi where zi is the design matrix for the bivariate random effects (b10,b11,b20,b21) solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[c(1,3),]}}).  There should be one unique value per subject

\item[\code{id}] sum(n\_i) vector of subject ids

\item[\code{beta}] mean model parameter p-vector

\item[\code{sigma.vc}] vector of variance components on standard deviation scale

\item[\code{rho.vc}] vector of correlations among the random effects.  The length should be q choose 2

\item[\code{sigma.e}] std dev of the measurement error distribution

\item[\code{cutpoints}] A matrix with the first dimension equal to sum(n\_i).  These cutpoints define the sampling regions (bivariate Q\_i: each row is a vector of length 4 c(xlow, xhigh, ylow, yhigh); univariate Q\_i: each row is a vector of length 2 c(k1,k2) to define the sampling regions, i.e., low, middle, high).  Each subject should have n\_i rows of the same values.

\item[\code{SampProb}] A matrix with the first dimension equal to sum(n\_i).   Sampling probabilities from within each region (bivariate Q\_i: each row is a vector of length 2 c(central region, outlying region); univariate Q\_i: each row is a vector of length 3 with sampling probabilities for each region). Each subject should have n\_i rows of the same values.

\item[\code{Weights}] Subject specific sampling weights.  A vector of length sum(n\_i).  Not used unless using weighted Likelihood

\item[\code{CheeseCalc}] If FALSE, the function returns the gradient of the conditional log likelihood across all subjects.  If TRUE, the cheese part of the sandwich esitmator is calculated.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
If CheeseCalc=FALSE, gradient of conditional log likelihood.  If CheeseCalc=TRUE, the cheese part of the sandwich estimator is calculated.
\end{Value}
\HeaderA{LogLikeC2}{Calculate the conditional likelihood for the univariate and bivariate sampling cases across all subjects (Keep.liC=FALSE) or the subject specific contributions to the conditional likelihood along with the log-transformed ascertainment correction for multiple imputation (Keep.liC=TRUE).}{LogLikeC2}
%
\begin{Description}
Calculate the conditional likelihood for the univariate and bivariate sampling cases across all subjects (Keep.liC=FALSE) or the subject specific contributions to the conditional likelihood along with the log-transformed ascertainment correction for multiple imputation (Keep.liC=TRUE).
\end{Description}
%
\begin{Usage}
\begin{verbatim}
LogLikeC2(
  y,
  x,
  z,
  w.function,
  id,
  beta,
  sigma.vc,
  rho.vc,
  sigma.e,
  cutpoints,
  SampProb,
  Weights,
  Keep.liC = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{y}] response vector

\item[\code{x}] sum(n\_i) by p design matrix for fixed effects

\item[\code{z}] sum(n\_i) by q design matrix for random effects

\item[\code{w.function}] sum(n\_i) vector with possible values that include "mean" "intercept" "slope" and "bivar."  There should be one unique value per subject

\item[\code{id}] sum(n\_i) vector of subject ids

\item[\code{beta}] mean model parameter p-vector

\item[\code{sigma.vc}] vector of variance components on standard deviation scale

\item[\code{rho.vc}] vector of correlations among the random effects.  The length should be q choose 2

\item[\code{sigma.e}] std dev of the measurement error distribution

\item[\code{cutpoints}] A matrix with the first dimension equal to sum(n\_i).  These cutpoints define the sampling regions (bivariate Q\_i: each row is a vector of length 4 c(xlow, xhigh, ylow, yhigh); univariate Q\_i: each row is a vector of length 2 c(k1,k2) to define the sampling regions, i.e., low, middle, high).  Each subject should have n\_i rows of the same values.

\item[\code{SampProb}] A matrix with the first dimension equal to sum(n\_i).   Sampling probabilities from within each region (bivariate Q\_i: each row is a vector of length 2 c(central region, outlying region); univariate Q\_i: each row is a vector of length 3 with sampling probabilities for each region). Each subject should have n\_i rows of the same values.

\item[\code{Weights}] Subject specific sampling weights.  A vector of length sum(n\_i).  Not used unless using weighted Likelihood

\item[\code{Keep.liC}] If FALSE, the function returns the conditional log likelihood across all subjects.  If TRUE, subject specific contributions and exponentiated subject specific ascertainment corrections are returned in a list.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
If Keep.liC=FALSE, conditional log likelihood.  If Keep.liC=TRUE, a two-element list that contains subject specific likelihood contributions and exponentiated ascertainment corrections.
\end{Value}
\HeaderA{LogLikeCAndScore2}{Calculate the ascertainment corrected log likelihood and score}{LogLikeCAndScore2}
%
\begin{Description}
Calculate the ascertainment corrected log likelihood and score
\end{Description}
%
\begin{Usage}
\begin{verbatim}
LogLikeCAndScore2(
  params,
  y,
  x,
  z,
  id,
  w.function,
  cutpoints,
  SampProb,
  Weights,
  ProfileCol = NA,
  Keep.liC = FALSE
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{params}] parameter vector c(beta, log(sigma0), log(sigma1), rho, sigmae)

\item[\code{y}] response vector

\item[\code{x}] sum(n\_i) by p design matrix for fixed effects

\item[\code{z}] sum(n\_i) by 2 design matric for random effects (intercept and slope)

\item[\code{id}] sum(n\_i) vector of subject ids

\item[\code{w.function}] sum(n\_i) vector with possible values that include "mean" (mean of response series), "intercept" (intercept of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[1,]}}), "intercept1"  (intercept of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[1,]}}). "intercept2" (second intercept of the regression of the Yi \textasciitilde{} zi where zi is the design matrix for the bivariate random effects (b10,b11,b20,b21) solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[3,]}}), "slope" (slope of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[2,]}}), "slope1" (slope of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[2,]}}), "slope2" (second slope of the regression of the Yi \textasciitilde{} zi where zi is the design matrix for the bivariate random effects (b10,b11,b20,b21) solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[4,]}}) "bivar" (intercept and slope of the regression of Yi \textasciitilde{} zi where zi is the design matrix for the random effects (solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[c(1,2),]}}) "mvints" (first and second intercepts of the bivariate regression of the Yi \textasciitilde{} zi where zi is the design matrix for the bivariate random effects (b10,b11,b20,b21) solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[c(1,3),]}}) "mvslps" (first and second slopes of the bivariate regression of the Yi \textasciitilde{} zi where zi is the design matrix for the bivariate random effects (b10,b11,b20,b21) solve(t.zi \%\emph{\% zi) \%}\% t.zi)\AsIs{\texttt{[c(1,3),]}}).  There should be one unique value per subject

\item[\code{cutpoints}] A matrix with the first dimension equal to sum(n\_i).  These cutpoints define the sampling regions (bivariate Q\_i: each row is a vector of length 4 c(xlow, xhigh, ylow, yhigh); univariate Q\_i: each row is a vector of length 2 c(k1,k2) to define the sampling regions, i.e., low, middle, high).  Each subject should have n\_i rows of the same values.

\item[\code{SampProb}] A matrix with the first dimension equal to sum(n\_i).   Sampling probabilities from within each region (bivariate Q\_i: each row is a vector of length 2 c(central region, outlying region); univariate Q\_i: each row is a vector of length 3 with sampling probabilities for each region). Each subject should have n\_i rows of the same values.

\item[\code{Weights}] Subject specific sampling weights.  A vector of length sum(n\_i).  Not used unless using weighted Likelihood

\item[\code{ProfileCol}] the column number(s) for which we want fixed at the value of param.  Maimizing the log likelihood for all other parameters
while fixing these columns at the values of \code{params[ProfileCol]}

\item[\code{Keep.liC}] If TRUE outputs subject specific conditional log lileihoods to be used for the imputation procedure described in the AOAS paper keep z sum(n\_i) by 2 design matric for random effects (intercept and slope)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
The conditional log likelihood with a "gradient" attribute (if Keep.liC=FALSE) and subject specific contributions to the conditional likelihood if Keep.liC=TRUE).
\end{Value}
\HeaderA{LogLikeiC2}{Calculate the ss contributions to the conditional likelihood for the univariate and bivariate sampling cases.}{LogLikeiC2}
%
\begin{Description}
Calculate the ss contributions to the conditional likelihood for the univariate and bivariate sampling cases.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
LogLikeiC2(subjectData, beta, sigma.vc, rho.vc, sigma.e)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{subjectData}] a list containing: yi, xi, zi, Weights.i, w.function.i, SampProb.i, cutpoints.i

\item[\code{beta}] mean model parameter p-vector

\item[\code{sigma.vc}] vector of variance components on standard deviation scale

\item[\code{rho.vc}] vector of correlations among the random effects.  The length should be q choose 2

\item[\code{sigma.e}] std dev of the measurement error distribution
\end{ldescription}
\end{Arguments}
%
\begin{Value}
ss contributions to the conditional log likelihood.  This is an internal function used by LogLikeC2
\end{Value}
\HeaderA{mcmc\_forest}{Create a forest plot of MCMC output}{mcmc.Rul.forest}
%
\begin{Description}
A wrapper around MCMCvis::MCMCplot to create forest plots of MCMC samples.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mcmc_forest(mcmc_output)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mcmc\_output}] MCMC output object (e.g., from fit\_model)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A forest plot of parameter estimates
\end{Value}
\HeaderA{mcmc\_summary}{Extract MCMC summary statistics}{mcmc.Rul.summary}
%
\begin{Description}
A wrapper around MCMCvis::MCMCsummary to extract summary statistics from
MCMC samples.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mcmc_summary(mcmc_output, dataset_id)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mcmc\_output}] MCMC output object (e.g., from fit\_model)

\item[\code{dataset\_id}] A character string identifying the dataset (added as a column)
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A data frame with summary statistics for each parameter
\end{Value}
\HeaderA{mcmc\_trace}{Plot MCMC trace plots}{mcmc.Rul.trace}
%
\begin{Description}
A wrapper around MCMCvis::MCMCtrace to create trace plots of MCMC samples.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mcmc_trace(mcmc_output, print_to_pdf = FALSE)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{mcmc\_output}] MCMC output object (e.g., from fit\_model)

\item[\code{print\_to\_pdf}] Logical; if TRUE, saves trace plots to a PDF file
\end{ldescription}
\end{Arguments}
%
\begin{Value}
Trace plots of MCMC samples
\end{Value}
\HeaderA{ods\_design}{Set x to missing based on an ODS design}{ods.Rul.design}
%
\begin{Description}
Set x to missing based on an ODS design
\end{Description}
%
\begin{Usage}
\begin{verbatim}
ods_design(
  data,
  sampling_type,
  cutoff_high,
  cutoff_low,
  sampling_N,
  prop_high,
  prop_middle,
  prop_low
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] Dataset to use

\item[\code{sampling\_type}] Which type of sampling? "intercept" or "slope"

\item[\code{cutoff\_high}] Which quantile to use as the cutoff for the High category

\item[\code{cutoff\_low}] Which quantile to use as the cutoff for the Low category

\item[\code{sampling\_N}] How many subjects should be sampled?

\item[\code{prop\_high}] What proportion to sample from the High category?

\item[\code{prop\_middle}] What proportion to sample from the Middle category?

\item[\code{prop\_low}] What proportion to sample from the Low category?
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A dataset where the x values are selected based on an ODS design
\end{Value}
\HeaderA{plot\_data}{Plot simulated data}{plot.Rul.data}
%
\begin{Description}
Plot simulated data
\end{Description}
%
\begin{Usage}
\begin{verbatim}
plot_data(data, subset_size = 200)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] Dataset to use

\item[\code{subset\_size}] How many subjects to use?
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A ggplot2 object
\end{Value}
\HeaderA{set\_missing}{Given selected subjects, set X to missing for those not selected}{set.Rul.missing}
%
\begin{Description}
Given selected subjects, set X to missing for those not selected
\end{Description}
%
\begin{Usage}
\begin{verbatim}
set_missing(data, selected_ids)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] Input data frame

\item[\code{selected\_ids}] IDs for the selected subjects
\end{ldescription}
\end{Arguments}
%
\begin{Value}
data.frame
\end{Value}
\HeaderA{srs\_design}{Set x to missing based on an SRS design}{srs.Rul.design}
%
\begin{Description}
Set x to missing based on an SRS design
\end{Description}
%
\begin{Usage}
\begin{verbatim}
srs_design(data, sampling_N)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{data}] Dataset to use

\item[\code{sampling\_N}] How many subjects to sample?
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A dataset where the x values are selected based on an SRS design
\end{Value}
\HeaderA{vi.calc}{Calculate V\_i = Z\_i D t(Z\_i) + sig\_e\textasciicircum{}2 \code{I\_(n\_i)}}{vi.calc}
%
\begin{Description}
Calculate V\_i = Z\_i D t(Z\_i) + sig\_e\textasciicircum{}2 \code{I\_(n\_i)}
\end{Description}
%
\begin{Usage}
\begin{verbatim}
vi.calc(zi, sigma.vc, rho.vc, sigma.e)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{zi}] n\_i by q design matrix for the random effects

\item[\code{sigma.vc}] vector of variance components on standard deviation scale

\item[\code{rho.vc}] vector of correlations among the random effects.  The length should be q choose 2

\item[\code{sigma.e}] std dev of the measurement error distribution
\end{ldescription}
\end{Arguments}
%
\begin{Value}
V\_i
\end{Value}
\printindex{}
\end{document}
